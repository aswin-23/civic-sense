{
  "version": 3,
  "sources": ["../../../../../../node_modules/@sutton-signwriting/sgnw-components/dist/esm/_commonjsHelpers-383fba37.js"],
  "sourcesContent": ["/*!\n * The Sutton SignWriting Web Components\n */\nconst NAMESPACE = 'sgnw-components';\nlet scopeId;\nlet contentRef;\nlet hostTagName;\nlet useNativeShadowDom = false;\nlet checkSlotFallbackVisibility = false;\nlet checkSlotRelocate = false;\nlet isSvgMode = false;\nlet queuePending = false;\nconst win = typeof window !== 'undefined' ? window : {};\nconst doc = win.document || {\n  head: {}\n};\nconst plt = {\n  $flags$: 0,\n  $resourcesUrl$: '',\n  jmp: h => h(),\n  raf: h => requestAnimationFrame(h),\n  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n  ce: (eventName, opts) => new CustomEvent(eventName, opts)\n};\nconst promiseResolve = v => Promise.resolve(v);\nconst supportsConstructibleStylesheets = /*@__PURE__*/(() => {\n  try {\n    new CSSStyleSheet();\n    return typeof new CSSStyleSheet().replace === 'function';\n  } catch (e) {}\n  return false;\n})();\nconst addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {\n  if (listeners) {\n    listeners.map(([flags, name, method]) => {\n      const target = getHostListenerTarget(elm, flags);\n      const handler = hostListenerProxy(hostRef, method);\n      const opts = hostListenerOpts(flags);\n      plt.ael(target, name, handler, opts);\n      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));\n    });\n  }\n};\nconst hostListenerProxy = (hostRef, methodName) => ev => {\n  try {\n    {\n      if (hostRef.$flags$ & 256 /* isListenReady */) {\n        // instance is ready, let's call it's member method for this event\n        hostRef.$lazyInstance$[methodName](ev);\n      } else {\n        (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n      }\n    }\n  } catch (e) {\n    consoleError(e);\n  }\n};\nconst getHostListenerTarget = (elm, flags) => {\n  if (flags & 8 /* TargetWindow */) return win;\n  return elm;\n};\n// prettier-ignore\nconst hostListenerOpts = flags => (flags & 2 /* Capture */) !== 0;\nconst HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';\nconst createTime = (fnName, tagName = '') => {\n  {\n    return () => {\n      return;\n    };\n  }\n};\nconst uniqueTime = (key, measureText) => {\n  {\n    return () => {\n      return;\n    };\n  }\n};\nconst rootAppliedStyles = new WeakMap();\nconst registerStyle = (scopeId, cssText, allowCS) => {\n  let style = styles.get(scopeId);\n  if (supportsConstructibleStylesheets && allowCS) {\n    style = style || new CSSStyleSheet();\n    style.replace(cssText);\n  } else {\n    style = cssText;\n  }\n  styles.set(scopeId, style);\n};\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {\n  let scopeId = getScopeId(cmpMeta);\n  const style = styles.get(scopeId);\n  // if an element is NOT connected then getRootNode() will return the wrong root node\n  // so the fallback is to always use the document for the root node in those cases\n  styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;\n  if (style) {\n    if (typeof style === 'string') {\n      styleContainerNode = styleContainerNode.head || styleContainerNode;\n      let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n      let styleElm;\n      if (!appliedStyles) {\n        rootAppliedStyles.set(styleContainerNode, appliedStyles = new Set());\n      }\n      if (!appliedStyles.has(scopeId)) {\n        {\n          {\n            styleElm = doc.createElement('style');\n            styleElm.innerHTML = style;\n          }\n          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\n        }\n        if (appliedStyles) {\n          appliedStyles.add(scopeId);\n        }\n      }\n    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {\n      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\n    }\n  }\n  return scopeId;\n};\nconst attachStyles = hostRef => {\n  const cmpMeta = hostRef.$cmpMeta$;\n  const elm = hostRef.$hostElement$;\n  const flags = cmpMeta.$flags$;\n  const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\n  const scopeId = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta);\n  if (flags & 10 /* needsScopedEncapsulation */) {\n    // only required when we're NOT using native shadow dom (slot)\n    // or this browser doesn't support native shadow dom\n    // and this host element was NOT created with SSR\n    // let's pick out the inner content for slot projection\n    // create a node to represent where the original\n    // content was first placed, which is useful later on\n    // DOM WRITE!!\n    elm['s-sc'] = scopeId;\n    elm.classList.add(scopeId + '-h');\n    if (flags & 2 /* scopedCssEncapsulation */) {\n      elm.classList.add(scopeId + '-s');\n    }\n  }\n  endAttachStyles();\n};\nconst getScopeId = (cmp, mode) => 'sc-' + cmp.$tagName$;\n/**\n * Default style mode id\n */\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\nconst EMPTY_OBJ = {};\n/**\n * Namespaces\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst HTML_NS = 'http://www.w3.org/1999/xhtml';\nconst isDef = v => v != null;\nconst isComplexType = o => {\n  // https://jsperf.com/typeof-fn-object/5\n  o = typeof o;\n  return o === 'object' || o === 'function';\n};\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h = (nodeName, vnodeData, ...children) => {\n  let child = null;\n  let slotName = null;\n  let simple = false;\n  let lastSimple = false;\n  const vNodeChildren = [];\n  const walk = c => {\n    for (let i = 0; i < c.length; i++) {\n      child = c[i];\n      if (Array.isArray(child)) {\n        walk(child);\n      } else if (child != null && typeof child !== 'boolean') {\n        if (simple = typeof nodeName !== 'function' && !isComplexType(child)) {\n          child = String(child);\n        }\n        if (simple && lastSimple) {\n          // If the previous child was simple (string), we merge both\n          vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n        } else {\n          // Append a new vNode, if it's text, we create a text vNode\n          vNodeChildren.push(simple ? newVNode(null, child) : child);\n        }\n        lastSimple = simple;\n      }\n    }\n  };\n  walk(children);\n  if (vnodeData) {\n    if (vnodeData.name) {\n      slotName = vnodeData.name;\n    }\n    {\n      const classData = vnodeData.className || vnodeData.class;\n      if (classData) {\n        vnodeData.class = typeof classData !== 'object' ? classData : Object.keys(classData).filter(k => classData[k]).join(' ');\n      }\n    }\n  }\n  const vnode = newVNode(nodeName, null);\n  vnode.$attrs$ = vnodeData;\n  if (vNodeChildren.length > 0) {\n    vnode.$children$ = vNodeChildren;\n  }\n  {\n    vnode.$name$ = slotName;\n  }\n  return vnode;\n};\nconst newVNode = (tag, text) => {\n  const vnode = {\n    $flags$: 0,\n    $tag$: tag,\n    $text$: text,\n    $elm$: null,\n    $children$: null\n  };\n  {\n    vnode.$attrs$ = null;\n  }\n  {\n    vnode.$name$ = null;\n  }\n  return vnode;\n};\nconst Host = {};\nconst isHost = node => node && node.$tag$ === Host;\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n  if (oldValue !== newValue) {\n    let isProp = isMemberInElement(elm, memberName);\n    let ln = memberName.toLowerCase();\n    if (memberName === 'class') {\n      const classList = elm.classList;\n      const oldClasses = parseClassList(oldValue);\n      const newClasses = parseClassList(newValue);\n      classList.remove(...oldClasses.filter(c => c && !newClasses.includes(c)));\n      classList.add(...newClasses.filter(c => c && !oldClasses.includes(c)));\n    } else if (memberName === 'style') {\n      // update style attribute, css properties and values\n      {\n        for (const prop in oldValue) {\n          if (!newValue || newValue[prop] == null) {\n            if (prop.includes('-')) {\n              elm.style.removeProperty(prop);\n            } else {\n              elm.style[prop] = '';\n            }\n          }\n        }\n      }\n      for (const prop in newValue) {\n        if (!oldValue || newValue[prop] !== oldValue[prop]) {\n          if (prop.includes('-')) {\n            elm.style.setProperty(prop, newValue[prop]);\n          } else {\n            elm.style[prop] = newValue[prop];\n          }\n        }\n      }\n    } else if (!isProp && memberName[0] === 'o' && memberName[1] === 'n') {\n      // Event Handlers\n      // so if the member name starts with \"on\" and the 3rd characters is\n      // a capital letter, and it's not already a member on the element,\n      // then we're assuming it's an event listener\n      if (memberName[2] === '-') {\n        // on- prefixed events\n        // allows to be explicit about the dom event to listen without any magic\n        // under the hood:\n        // <my-cmp on-click> // listens for \"click\"\n        // <my-cmp on-Click> // listens for \"Click\"\n        // <my-cmp on-ionChange> // listens for \"ionChange\"\n        // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n        memberName = memberName.slice(3);\n      } else if (isMemberInElement(win, ln)) {\n        // standard event\n        // the JSX attribute could have been \"onMouseOver\" and the\n        // member name \"onmouseover\" is on the window's prototype\n        // so let's add the listener \"mouseover\", which is all lowercased\n        memberName = ln.slice(2);\n      } else {\n        // custom event\n        // the JSX attribute could have been \"onMyCustomEvent\"\n        // so let's trim off the \"on\" prefix and lowercase the first character\n        // and add the listener \"myCustomEvent\"\n        // except for the first character, we keep the event name case\n        memberName = ln[2] + memberName.slice(3);\n      }\n      if (oldValue) {\n        plt.rel(elm, memberName, oldValue, false);\n      }\n      if (newValue) {\n        plt.ael(elm, memberName, newValue, false);\n      }\n    } else {\n      // Set property if it exists and it's not a SVG\n      const isComplex = isComplexType(newValue);\n      if ((isProp || isComplex && newValue !== null) && !isSvg) {\n        try {\n          if (!elm.tagName.includes('-')) {\n            const n = newValue == null ? '' : newValue;\n            // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n            if (memberName === 'list') {\n              isProp = false;\n            } else if (oldValue == null || elm[memberName] != n) {\n              elm[memberName] = n;\n            }\n          } else {\n            elm[memberName] = newValue;\n          }\n        } catch (e) {}\n      }\n      if (newValue == null || newValue === false) {\n        if (newValue !== false || elm.getAttribute(memberName) === '') {\n          {\n            elm.removeAttribute(memberName);\n          }\n        }\n      } else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {\n        newValue = newValue === true ? '' : newValue;\n        {\n          elm.setAttribute(memberName, newValue);\n        }\n      }\n    }\n  }\n};\nconst parseClassListRegex = /\\s/;\nconst parseClassList = value => !value ? [] : value.split(parseClassListRegex);\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\n  // if the element passed in is a shadow root, which is a document fragment\n  // then we want to be adding attrs/props to the shadow root's \"host\" element\n  // if it's not a shadow root, then we add attrs/props to the same element\n  const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;\n  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;\n  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n  {\n    // remove attributes no longer present on the vnode by setting them to undefined\n    for (memberName in oldVnodeAttrs) {\n      if (!(memberName in newVnodeAttrs)) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n      }\n    }\n  }\n  // add new & update changed attributes\n  for (memberName in newVnodeAttrs) {\n    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n  }\n};\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n  // tslint:disable-next-line: prefer-const\n  const newVNode = newParentVNode.$children$[childIndex];\n  let i = 0;\n  let elm;\n  let childNode;\n  let oldVNode;\n  if (!useNativeShadowDom) {\n    // remember for later we need to check to relocate nodes\n    checkSlotRelocate = true;\n    if (newVNode.$tag$ === 'slot') {\n      if (scopeId) {\n        // scoped css needs to add its scoped id to the parent element\n        parentElm.classList.add(scopeId + '-s');\n      }\n      newVNode.$flags$ |= newVNode.$children$ ?\n      // slot element has fallback content\n      2 /* isSlotFallback */ :\n      // slot element does not have fallback content\n      1 /* isSlotReference */;\n    }\n  }\n  if (newVNode.$text$ !== null) {\n    // create text node\n    elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n  } else if (newVNode.$flags$ & 1 /* isSlotReference */) {\n    // create a slot reference node\n    elm = newVNode.$elm$ = doc.createTextNode('');\n  } else {\n    if (!isSvgMode) {\n      isSvgMode = newVNode.$tag$ === 'svg';\n    }\n    // create element\n    elm = newVNode.$elm$ = doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, newVNode.$flags$ & 2 /* isSlotFallback */ ? 'slot-fb' : newVNode.$tag$);\n    if (isSvgMode && newVNode.$tag$ === 'foreignObject') {\n      isSvgMode = false;\n    }\n    // add css classes, attrs, props, listeners, etc.\n    {\n      updateElement(null, newVNode, isSvgMode);\n    }\n    if (isDef(scopeId) && elm['s-si'] !== scopeId) {\n      // if there is a scopeId and this is the initial render\n      // then let's add the scopeId as a css class\n      elm.classList.add(elm['s-si'] = scopeId);\n    }\n    if (newVNode.$children$) {\n      for (i = 0; i < newVNode.$children$.length; ++i) {\n        // create the node\n        childNode = createElm(oldParentVNode, newVNode, i, elm);\n        // return node could have been null\n        if (childNode) {\n          // append our new node\n          elm.appendChild(childNode);\n        }\n      }\n    }\n    {\n      if (newVNode.$tag$ === 'svg') {\n        // Only reset the SVG context when we're exiting <svg> element\n        isSvgMode = false;\n      } else if (elm.tagName === 'foreignObject') {\n        // Reenter SVG context when we're exiting <foreignObject> element\n        isSvgMode = true;\n      }\n    }\n  }\n  {\n    elm['s-hn'] = hostTagName;\n    if (newVNode.$flags$ & (2 /* isSlotFallback */ | 1 /* isSlotReference */)) {\n      // remember the content reference comment\n      elm['s-sr'] = true;\n      // remember the content reference comment\n      elm['s-cr'] = contentRef;\n      // remember the slot name, or empty string for default slot\n      elm['s-sn'] = newVNode.$name$ || '';\n      // check if we've got an old vnode for this slot\n      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n      if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {\n        // we've got an old slot vnode and the wrapper is being replaced\n        // so let's move the old slot content back to it's original location\n        putBackInOriginalLocation(oldParentVNode.$elm$, false);\n      }\n    }\n  }\n  return elm;\n};\nconst putBackInOriginalLocation = (parentElm, recursive) => {\n  plt.$flags$ |= 1 /* isTmpDisconnected */;\n  const oldSlotChildNodes = parentElm.childNodes;\n  for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {\n    const childNode = oldSlotChildNodes[i];\n    if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {\n      // // this child node in the old element is from another component\n      // // remove this node from the old slot's parent\n      // childNode.remove();\n      // and relocate it back to it's original location\n      parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));\n      // remove the old original location comment entirely\n      // later on the patch function will know what to do\n      // and move this to the correct spot in need be\n      childNode['s-ol'].remove();\n      childNode['s-ol'] = undefined;\n      checkSlotRelocate = true;\n    }\n    if (recursive) {\n      putBackInOriginalLocation(childNode, recursive);\n    }\n  }\n  plt.$flags$ &= ~1 /* isTmpDisconnected */;\n};\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n  let containerElm = parentElm['s-cr'] && parentElm['s-cr'].parentNode || parentElm;\n  let childNode;\n  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n    containerElm = containerElm.shadowRoot;\n  }\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnodes[startIdx]) {\n      childNode = createElm(null, parentVNode, startIdx, parentElm);\n      if (childNode) {\n        vnodes[startIdx].$elm$ = childNode;\n        containerElm.insertBefore(childNode, referenceNode(before));\n      }\n    }\n  }\n};\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnode = vnodes[startIdx]) {\n      elm = vnode.$elm$;\n      {\n        // we're removing this element\n        // so it's possible we need to show slot fallback content now\n        checkSlotFallbackVisibility = true;\n        if (elm['s-ol']) {\n          // remove the original location comment\n          elm['s-ol'].remove();\n        } else {\n          // it's possible that child nodes of the node\n          // that's being removed are slot nodes\n          putBackInOriginalLocation(elm, true);\n        }\n      }\n      // remove the vnode's element from the dom\n      elm.remove();\n    }\n  }\n};\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\n  let oldStartIdx = 0;\n  let newStartIdx = 0;\n  let oldEndIdx = oldCh.length - 1;\n  let oldStartVnode = oldCh[0];\n  let oldEndVnode = oldCh[oldEndIdx];\n  let newEndIdx = newCh.length - 1;\n  let newStartVnode = newCh[0];\n  let newEndVnode = newCh[newEndIdx];\n  let node;\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      // Vnode might have been moved left\n      oldStartVnode = oldCh[++oldStartIdx];\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newStartVnode)) {\n      patch(oldStartVnode, newStartVnode);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n      patch(oldEndVnode, newEndVnode);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newEndVnode)) {\n      // Vnode moved right\n      if (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot') {\n        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n      }\n      patch(oldStartVnode, newEndVnode);\n      parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldEndVnode, newStartVnode)) {\n      // Vnode moved left\n      if (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot') {\n        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n      }\n      patch(oldEndVnode, newStartVnode);\n      parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      {\n        // new element\n        node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);\n        newStartVnode = newCh[++newStartIdx];\n      }\n      if (node) {\n        {\n          parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));\n        }\n      }\n    }\n  }\n  if (oldStartIdx > oldEndIdx) {\n    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n  } else if (newStartIdx > newEndIdx) {\n    removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n  }\n};\nconst isSameVnode = (vnode1, vnode2) => {\n  // compare if two vnode to see if they're \"technically\" the same\n  // need to have the same element tag, and same key to be the same\n  if (vnode1.$tag$ === vnode2.$tag$) {\n    if (vnode1.$tag$ === 'slot') {\n      return vnode1.$name$ === vnode2.$name$;\n    }\n    return true;\n  }\n  return false;\n};\nconst referenceNode = node => {\n  // this node was relocated to a new location in the dom\n  // because of some other component's slot\n  // but we still have an html comment in place of where\n  // it's original location was according to it's original vdom\n  return node && node['s-ol'] || node;\n};\nconst parentReferenceNode = node => (node['s-ol'] ? node['s-ol'] : node).parentNode;\nconst patch = (oldVNode, newVNode) => {\n  const elm = newVNode.$elm$ = oldVNode.$elm$;\n  const oldChildren = oldVNode.$children$;\n  const newChildren = newVNode.$children$;\n  const tag = newVNode.$tag$;\n  const text = newVNode.$text$;\n  let defaultHolder;\n  if (text === null) {\n    {\n      // test if we're rendering an svg element, or still rendering nodes inside of one\n      // only add this to the when the compiler sees we're using an svg somewhere\n      isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;\n    }\n    // element node\n    {\n      if (tag === 'slot') ;else {\n        // either this is the first render of an element OR it's an update\n        // AND we already know it's possible it could have changed\n        // this updates the element's css classes, attrs, props, listeners, etc.\n        updateElement(oldVNode, newVNode, isSvgMode);\n      }\n    }\n    if (oldChildren !== null && newChildren !== null) {\n      // looks like there's child vnodes for both the old and new vnodes\n      updateChildren(elm, oldChildren, newVNode, newChildren);\n    } else if (newChildren !== null) {\n      // no old child vnodes, but there are new child vnodes to add\n      if (oldVNode.$text$ !== null) {\n        // the old vnode was text, so be sure to clear it out\n        elm.textContent = '';\n      }\n      // add the new vnode children\n      addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n    } else if (oldChildren !== null) {\n      // no new child vnodes, but there are old child vnodes to remove\n      removeVnodes(oldChildren, 0, oldChildren.length - 1);\n    }\n    if (isSvgMode && tag === 'svg') {\n      isSvgMode = false;\n    }\n  } else if (defaultHolder = elm['s-cr']) {\n    // this element has slotted content\n    defaultHolder.parentNode.textContent = text;\n  } else if (oldVNode.$text$ !== text) {\n    // update the text content for the text only vnode\n    // and also only if the text is different than before\n    elm.data = text;\n  }\n};\nconst updateFallbackSlotVisibility = elm => {\n  // tslint:disable-next-line: prefer-const\n  const childNodes = elm.childNodes;\n  let childNode;\n  let i;\n  let ilen;\n  let j;\n  let slotNameAttr;\n  let nodeType;\n  for (i = 0, ilen = childNodes.length; i < ilen; i++) {\n    childNode = childNodes[i];\n    if (childNode.nodeType === 1 /* ElementNode */) {\n      if (childNode['s-sr']) {\n        // this is a slot fallback node\n        // get the slot name for this slot reference node\n        slotNameAttr = childNode['s-sn'];\n        // by default always show a fallback slot node\n        // then hide it if there are other slots in the light dom\n        childNode.hidden = false;\n        for (j = 0; j < ilen; j++) {\n          nodeType = childNodes[j].nodeType;\n          if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {\n            // this sibling node is from a different component OR is a named fallback slot node\n            if (nodeType === 1 /* ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {\n              childNode.hidden = true;\n              break;\n            }\n          } else {\n            // this is a default fallback slot node\n            // any element or text node (with content)\n            // should hide the default fallback slot node\n            if (nodeType === 1 /* ElementNode */ || nodeType === 3 /* TextNode */ && childNodes[j].textContent.trim() !== '') {\n              childNode.hidden = true;\n              break;\n            }\n          }\n        }\n      }\n      // keep drilling down\n      updateFallbackSlotVisibility(childNode);\n    }\n  }\n};\nconst relocateNodes = [];\nconst relocateSlotContent = elm => {\n  // tslint:disable-next-line: prefer-const\n  let childNode;\n  let node;\n  let hostContentNodes;\n  let slotNameAttr;\n  let relocateNodeData;\n  let j;\n  let i = 0;\n  const childNodes = elm.childNodes;\n  const ilen = childNodes.length;\n  for (; i < ilen; i++) {\n    childNode = childNodes[i];\n    if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {\n      // first got the content reference comment node\n      // then we got it's parent, which is where all the host content is in now\n      hostContentNodes = node.parentNode.childNodes;\n      slotNameAttr = childNode['s-sn'];\n      for (j = hostContentNodes.length - 1; j >= 0; j--) {\n        node = hostContentNodes[j];\n        if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {\n          // let's do some relocating to its new home\n          // but never relocate a content reference node\n          // that is suppose to always represent the original content location\n          if (isNodeLocatedInSlot(node, slotNameAttr)) {\n            // it's possible we've already decided to relocate this node\n            relocateNodeData = relocateNodes.find(r => r.$nodeToRelocate$ === node);\n            // made some changes to slots\n            // let's make sure we also double check\n            // fallbacks are correctly hidden or shown\n            checkSlotFallbackVisibility = true;\n            node['s-sn'] = node['s-sn'] || slotNameAttr;\n            if (relocateNodeData) {\n              // previously we never found a slot home for this node\n              // but turns out we did, so let's remember it now\n              relocateNodeData.$slotRefNode$ = childNode;\n            } else {\n              // add to our list of nodes to relocate\n              relocateNodes.push({\n                $slotRefNode$: childNode,\n                $nodeToRelocate$: node\n              });\n            }\n            if (node['s-sr']) {\n              relocateNodes.map(relocateNode => {\n                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {\n                  relocateNodeData = relocateNodes.find(r => r.$nodeToRelocate$ === node);\n                  if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                  }\n                }\n              });\n            }\n          } else if (!relocateNodes.some(r => r.$nodeToRelocate$ === node)) {\n            // so far this element does not have a slot home, not setting slotRefNode on purpose\n            // if we never find a home for this element then we'll need to hide it\n            relocateNodes.push({\n              $nodeToRelocate$: node\n            });\n          }\n        }\n      }\n    }\n    if (childNode.nodeType === 1 /* ElementNode */) {\n      relocateSlotContent(childNode);\n    }\n  }\n};\nconst isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {\n  if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n    if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {\n      return true;\n    }\n    if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {\n      return true;\n    }\n    return false;\n  }\n  if (nodeToRelocate['s-sn'] === slotNameAttr) {\n    return true;\n  }\n  return slotNameAttr === '';\n};\nconst renderVdom = (hostRef, renderFnResults) => {\n  const hostElm = hostRef.$hostElement$;\n  const cmpMeta = hostRef.$cmpMeta$;\n  const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n  const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n  hostTagName = hostElm.tagName;\n  if (cmpMeta.$attrsToReflect$) {\n    rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n    cmpMeta.$attrsToReflect$.map(([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]);\n  }\n  rootVnode.$tag$ = null;\n  rootVnode.$flags$ |= 4 /* isHost */;\n  hostRef.$vnode$ = rootVnode;\n  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;\n  {\n    scopeId = hostElm['s-sc'];\n  }\n  {\n    contentRef = hostElm['s-cr'];\n    useNativeShadowDom = (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) !== 0;\n    // always reset\n    checkSlotFallbackVisibility = false;\n  }\n  // synchronous patch\n  patch(oldVNode, rootVnode);\n  {\n    // while we're moving nodes around existing nodes, temporarily disable\n    // the disconnectCallback from working\n    plt.$flags$ |= 1 /* isTmpDisconnected */;\n    if (checkSlotRelocate) {\n      relocateSlotContent(rootVnode.$elm$);\n      let relocateData;\n      let nodeToRelocate;\n      let orgLocationNode;\n      let parentNodeRef;\n      let insertBeforeNode;\n      let refNode;\n      let i = 0;\n      for (; i < relocateNodes.length; i++) {\n        relocateData = relocateNodes[i];\n        nodeToRelocate = relocateData.$nodeToRelocate$;\n        if (!nodeToRelocate['s-ol']) {\n          // add a reference node marking this node's original location\n          // keep a reference to this node for later lookups\n          orgLocationNode = doc.createTextNode('');\n          orgLocationNode['s-nr'] = nodeToRelocate;\n          nodeToRelocate.parentNode.insertBefore(nodeToRelocate['s-ol'] = orgLocationNode, nodeToRelocate);\n        }\n      }\n      for (i = 0; i < relocateNodes.length; i++) {\n        relocateData = relocateNodes[i];\n        nodeToRelocate = relocateData.$nodeToRelocate$;\n        if (relocateData.$slotRefNode$) {\n          // by default we're just going to insert it directly\n          // after the slot reference node\n          parentNodeRef = relocateData.$slotRefNode$.parentNode;\n          insertBeforeNode = relocateData.$slotRefNode$.nextSibling;\n          orgLocationNode = nodeToRelocate['s-ol'];\n          while (orgLocationNode = orgLocationNode.previousSibling) {\n            refNode = orgLocationNode['s-nr'];\n            if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {\n              refNode = refNode.nextSibling;\n              if (!refNode || !refNode['s-nr']) {\n                insertBeforeNode = refNode;\n                break;\n              }\n            }\n          }\n          if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {\n            // we've checked that it's worth while to relocate\n            // since that the node to relocate\n            // has a different next sibling or parent relocated\n            if (nodeToRelocate !== insertBeforeNode) {\n              if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {\n                // probably a component in the index.html that doesn't have it's hostname set\n                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;\n              }\n              // add it back to the dom but in its new home\n              parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);\n            }\n          }\n        } else {\n          // this node doesn't have a slot home to go to, so let's hide it\n          if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n            nodeToRelocate.hidden = true;\n          }\n        }\n      }\n    }\n    if (checkSlotFallbackVisibility) {\n      updateFallbackSlotVisibility(rootVnode.$elm$);\n    }\n    // done moving nodes around\n    // allow the disconnect callback to work again\n    plt.$flags$ &= ~1 /* isTmpDisconnected */;\n    // always reset\n    relocateNodes.length = 0;\n  }\n};\nconst getElement = ref => getHostRef(ref).$hostElement$;\nconst createEvent = (ref, name, flags) => {\n  const elm = getElement(ref);\n  return {\n    emit: detail => {\n      return emitEvent(elm, name, {\n        bubbles: !!(flags & 4 /* Bubbles */),\n        composed: !!(flags & 2 /* Composed */),\n        cancelable: !!(flags & 1 /* Cancellable */),\n        detail\n      });\n    }\n  };\n};\n/**\n * Helper function to create & dispatch a custom Event on a provided target\n * @param elm the target of the Event\n * @param name the name to give the custom Event\n * @param opts options for configuring a custom Event\n * @returns the custom Event\n */\nconst emitEvent = (elm, name, opts) => {\n  const ev = plt.ce(name, opts);\n  elm.dispatchEvent(ev);\n  return ev;\n};\nconst attachToAncestor = (hostRef, ancestorComponent) => {\n  if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {\n    ancestorComponent['s-p'].push(new Promise(r => hostRef.$onRenderResolve$ = r));\n  }\n};\nconst scheduleUpdate = (hostRef, isInitialLoad) => {\n  {\n    hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n  }\n  if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n    hostRef.$flags$ |= 512 /* needsRerender */;\n    return;\n  }\n  attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n  // there is no ancestor component or the ancestor component\n  // has already fired off its lifecycle update then\n  // fire off the initial update\n  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n  return writeTask(dispatch);\n};\nconst dispatchHooks = (hostRef, isInitialLoad) => {\n  const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);\n  const instance = hostRef.$lazyInstance$;\n  let promise;\n  if (isInitialLoad) {\n    {\n      hostRef.$flags$ |= 256 /* isListenReady */;\n      if (hostRef.$queuedListeners$) {\n        hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));\n        hostRef.$queuedListeners$ = null;\n      }\n    }\n    {\n      promise = safeCall(instance, 'componentWillLoad');\n    }\n  }\n  endSchedule();\n  return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nconst updateComponent = async (hostRef, instance, isInitialLoad) => {\n  // updateComponent\n  const elm = hostRef.$hostElement$;\n  const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);\n  const rc = elm['s-rc'];\n  if (isInitialLoad) {\n    // DOM WRITE!\n    attachStyles(hostRef);\n  }\n  const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);\n  {\n    callRender(hostRef, instance);\n  }\n  if (rc) {\n    // ok, so turns out there are some child host elements\n    // waiting on this parent element to load\n    // let's fire off all update callbacks waiting\n    rc.map(cb => cb());\n    elm['s-rc'] = undefined;\n  }\n  endRender();\n  endUpdate();\n  {\n    const childrenPromises = elm['s-p'];\n    const postUpdate = () => postUpdateComponent(hostRef);\n    if (childrenPromises.length === 0) {\n      postUpdate();\n    } else {\n      Promise.all(childrenPromises).then(postUpdate);\n      hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n      childrenPromises.length = 0;\n    }\n  }\n};\nconst callRender = (hostRef, instance, elm) => {\n  try {\n    instance = instance.render();\n    {\n      hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;\n    }\n    {\n      hostRef.$flags$ |= 2 /* hasRendered */;\n    }\n    {\n      {\n        // looks like we've got child nodes to render into this host element\n        // or we need to update the css class/attrs on the host element\n        // DOM WRITE!\n        {\n          renderVdom(hostRef, instance);\n        }\n      }\n    }\n  } catch (e) {\n    consoleError(e, hostRef.$hostElement$);\n  }\n  return null;\n};\nconst postUpdateComponent = hostRef => {\n  const tagName = hostRef.$cmpMeta$.$tagName$;\n  const elm = hostRef.$hostElement$;\n  const endPostUpdate = createTime('postUpdate', tagName);\n  const instance = hostRef.$lazyInstance$;\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n    hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n    {\n      // DOM WRITE!\n      addHydratedFlag(elm);\n    }\n    {\n      safeCall(instance, 'componentDidLoad');\n    }\n    endPostUpdate();\n    {\n      hostRef.$onReadyResolve$(elm);\n      if (!ancestorComponent) {\n        appDidLoad();\n      }\n    }\n  } else {\n    endPostUpdate();\n  }\n  // load events fire from bottom to top\n  // the deepest elements load first then bubbles up\n  {\n    if (hostRef.$onRenderResolve$) {\n      hostRef.$onRenderResolve$();\n      hostRef.$onRenderResolve$ = undefined;\n    }\n    if (hostRef.$flags$ & 512 /* needsRerender */) {\n      nextTick(() => scheduleUpdate(hostRef, false));\n    }\n    hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);\n  }\n  // ( •_•)\n  // ( •_•)>⌐■-■\n  // (⌐■_■)\n};\nconst appDidLoad = who => {\n  // on appload\n  // we have finish the first big initial render\n  {\n    addHydratedFlag(doc.documentElement);\n  }\n  nextTick(() => emitEvent(win, 'appload', {\n    detail: {\n      namespace: NAMESPACE\n    }\n  }));\n};\nconst safeCall = (instance, method, arg) => {\n  if (instance && instance[method]) {\n    try {\n      return instance[method](arg);\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n  return undefined;\n};\nconst then = (promise, thenFn) => {\n  return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\nconst addHydratedFlag = elm => elm.classList.add('hydrated');\n/**\n * Parse a new property value for a given property type.\n *\n * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,\n * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:\n *   1. `any`, the type given to `propValue` in the function signature\n *   2. the type stored from `propType`.\n *\n * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.\n *\n * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to\n * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is\n * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.\n * ```tsx\n * <my-cmp prop-val={0}></my-cmp>\n * ```\n *\n * HTML prop values on the other hand, will always a string\n *\n * @param propValue the new value to coerce to some type\n * @param propType the type of the prop, expressed as a binary number\n * @returns the parsed/coerced value\n */\nconst parsePropertyValue = (propValue, propType) => {\n  // ensure this value is of the correct prop type\n  if (propValue != null && !isComplexType(propValue)) {\n    if (propType & 4 /* Boolean */) {\n      // per the HTML spec, any string value means it is a boolean true value\n      // but we'll cheat here and say that the string \"false\" is the boolean false\n      return propValue === 'false' ? false : propValue === '' || !!propValue;\n    }\n    if (propType & 1 /* String */) {\n      // could have been passed as a number or boolean\n      // but we still want it as a string\n      return String(propValue);\n    }\n    // redundant return here for better minification\n    return propValue;\n  }\n  // not sure exactly what type we want\n  // so no need to change to a different type\n  return propValue;\n};\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nconst setValue = (ref, propName, newVal, cmpMeta) => {\n  // check our new property value against our internal value\n  const hostRef = getHostRef(ref);\n  const elm = hostRef.$hostElement$;\n  const oldVal = hostRef.$instanceValues$.get(propName);\n  const flags = hostRef.$flags$;\n  const instance = hostRef.$lazyInstance$;\n  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n  // explicitly check for NaN on both sides, as `NaN === NaN` is always false\n  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n  const didValueChange = newVal !== oldVal && !areBothNaN;\n  if ((!(flags & 8 /* isConstructingInstance */) || oldVal === undefined) && didValueChange) {\n    // gadzooks! the property's value has changed!!\n    // set our new value!\n    hostRef.$instanceValues$.set(propName, newVal);\n    if (instance) {\n      // get an array of method names of watch functions to call\n      if (cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {\n        const watchMethods = cmpMeta.$watchers$[propName];\n        if (watchMethods) {\n          // this instance is watching for when this property changed\n          watchMethods.map(watchMethodName => {\n            try {\n              // fire off each of the watch methods that are watching this property\n              instance[watchMethodName](newVal, oldVal, propName);\n            } catch (e) {\n              consoleError(e, elm);\n            }\n          });\n        }\n      }\n      if ((flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n        // looks like this value actually changed, so we've got work to do!\n        // but only if we've already rendered, otherwise just chill out\n        // queue that we need to do an update, but don't worry about queuing\n        // up millions cuz this function ensures it only runs once\n        scheduleUpdate(hostRef, false);\n      }\n    }\n  }\n};\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\n  if (cmpMeta.$members$) {\n    if (Cstr.watchers) {\n      cmpMeta.$watchers$ = Cstr.watchers;\n    }\n    // It's better to have a const than two Object.entries()\n    const members = Object.entries(cmpMeta.$members$);\n    const prototype = Cstr.prototype;\n    members.map(([memberName, [memberFlags]]) => {\n      if (memberFlags & 31 /* Prop */ || flags & 2 /* proxyState */ && memberFlags & 32 /* State */) {\n        // proxyComponent - prop\n        Object.defineProperty(prototype, memberName, {\n          get() {\n            // proxyComponent, get value\n            return getValue(this, memberName);\n          },\n          set(newValue) {\n            // proxyComponent, set value\n            setValue(this, memberName, newValue, cmpMeta);\n          },\n          configurable: true,\n          enumerable: true\n        });\n      }\n    });\n    if (flags & 1 /* isElementConstructor */) {\n      const attrNameToPropName = new Map();\n      prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n        plt.jmp(() => {\n          const propName = attrNameToPropName.get(attrName);\n          //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback\n          //  in the case where an attribute was set inline.\n          //  ```html\n          //    <my-component some-attribute=\"some-value\"></my-component>\n          //  ```\n          //\n          //  There is an edge case where a developer sets the attribute inline on a custom element and then\n          //  programmatically changes it before it has been upgraded as shown below:\n          //\n          //  ```html\n          //    <!-- this component has _not_ been upgraded yet -->\n          //    <my-component id=\"test\" some-attribute=\"some-value\"></my-component>\n          //    <script>\n          //      // grab non-upgraded component\n          //      el = document.querySelector(\"#test\");\n          //      el.someAttribute = \"another-value\";\n          //      // upgrade component\n          //      customElements.define('my-component', MyComponent);\n          //    </script>\n          //  ```\n          //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback\n          //  will be called with `newValue = \"some-value\"` and will set the shadowed property (this.someAttribute = \"another-value\")\n          //  to the value that was set inline i.e. \"some-value\" from above example. When\n          //  the connectedCallback attempts to unshadow it will use \"some-value\" as the initial value rather than \"another-value\"\n          //\n          //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed\n          //  by connectedCallback as this attributeChangedCallback will not fire.\n          //\n          //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n          //\n          //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to\n          //  properties here given that this goes against best practices outlined here\n          //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy\n          if (this.hasOwnProperty(propName)) {\n            newValue = this[propName];\n            delete this[propName];\n          } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === 'number' && this[propName] == newValue) {\n            // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native\n            // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in\n            // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.\n            return;\n          }\n          this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;\n        });\n      };\n      // create an array of attributes to observe\n      // and also create a map of html attribute name to js property name\n      Cstr.observedAttributes = members.filter(([_, m]) => m[0] & 15 /* HasAttribute */) // filter to only keep props that should match attributes\n      .map(([propName, m]) => {\n        const attrName = m[1] || propName;\n        attrNameToPropName.set(attrName, propName);\n        if (m[0] & 512 /* ReflectAttr */) {\n          cmpMeta.$attrsToReflect$.push([propName, attrName]);\n        }\n        return attrName;\n      });\n    }\n  }\n  return Cstr;\n};\nconst initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {\n  // initializeComponent\n  if ((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n    {\n      // we haven't initialized this element yet\n      hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n      // lazy loaded components\n      // request the component's implementation to be\n      // wired up with the host element\n      Cstr = loadModule(cmpMeta);\n      if (Cstr.then) {\n        // Await creates a micro-task avoid if possible\n        const endLoad = uniqueTime();\n        Cstr = await Cstr;\n        endLoad();\n      }\n      if (!Cstr.isProxied) {\n        // we've never proxied this Constructor before\n        // let's add the getters/setters to its prototype before\n        // the first time we create an instance of the implementation\n        {\n          cmpMeta.$watchers$ = Cstr.watchers;\n        }\n        proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);\n        Cstr.isProxied = true;\n      }\n      const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);\n      // ok, time to construct the instance\n      // but let's keep track of when we start and stop\n      // so that the getters/setters don't incorrectly step on data\n      {\n        hostRef.$flags$ |= 8 /* isConstructingInstance */;\n      }\n      // construct the lazy-loaded component implementation\n      // passing the hostRef is very important during\n      // construction in order to directly wire together the\n      // host element and the lazy-loaded instance\n      try {\n        new Cstr(hostRef);\n      } catch (e) {\n        consoleError(e);\n      }\n      {\n        hostRef.$flags$ &= ~8 /* isConstructingInstance */;\n      }\n      {\n        hostRef.$flags$ |= 128 /* isWatchReady */;\n      }\n      endNewInstance();\n      fireConnectedCallback(hostRef.$lazyInstance$);\n    }\n    if (Cstr.style) {\n      // this component has styles but we haven't registered them yet\n      let style = Cstr.style;\n      const scopeId = getScopeId(cmpMeta);\n      if (!styles.has(scopeId)) {\n        const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\n        registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n        endRegisterStyles();\n      }\n    }\n  }\n  // we've successfully created a lazy instance\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  const schedule = () => scheduleUpdate(hostRef, true);\n  if (ancestorComponent && ancestorComponent['s-rc']) {\n    // this is the initial load and this component it has an ancestor component\n    // but the ancestor component has NOT fired its will update lifecycle yet\n    // so let's just cool our jets and wait for the ancestor to continue first\n    // this will get fired off when the ancestor component\n    // finally gets around to rendering its lazy self\n    // fire off the initial update\n    ancestorComponent['s-rc'].push(schedule);\n  } else {\n    schedule();\n  }\n};\nconst fireConnectedCallback = instance => {\n  {\n    safeCall(instance, 'connectedCallback');\n  }\n};\nconst connectedCallback = elm => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    const hostRef = getHostRef(elm);\n    const cmpMeta = hostRef.$cmpMeta$;\n    const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\n    if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n      // first time this component has connected\n      hostRef.$flags$ |= 1 /* hasConnected */;\n      {\n        // initUpdate\n        // if the slot polyfill is required we'll need to put some nodes\n        // in here to act as original content anchors as we move nodes around\n        // host element has been connected to the DOM\n        if (cmpMeta.$flags$ & (4 /* hasSlotRelocation */ | 8 /* needsShadowDomShim */)) {\n          setContentReference(elm);\n        }\n      }\n      {\n        // find the first ancestor component (if there is one) and register\n        // this component as one of the actively loading child components for its ancestor\n        let ancestorComponent = elm;\n        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {\n          // climb up the ancestors looking for the first\n          // component that hasn't finished its lifecycle update yet\n          if (ancestorComponent['s-p']) {\n            // we found this components first ancestor component\n            // keep a reference to this component's ancestor component\n            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);\n            break;\n          }\n        }\n      }\n      // Lazy properties\n      // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n      if (cmpMeta.$members$) {\n        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n          if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n            const value = elm[memberName];\n            delete elm[memberName];\n            elm[memberName] = value;\n          }\n        });\n      }\n      {\n        initializeComponent(elm, hostRef, cmpMeta);\n      }\n    } else {\n      // not the first time this has connected\n      // reattach any event listeners to the host\n      // since they would have been removed when disconnected\n      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);\n      // fire off connectedCallback() on component instance\n      fireConnectedCallback(hostRef.$lazyInstance$);\n    }\n    endConnected();\n  }\n};\nconst setContentReference = elm => {\n  // only required when we're NOT using native shadow dom (slot)\n  // or this browser doesn't support native shadow dom\n  // and this host element was NOT created with SSR\n  // let's pick out the inner content for slot projection\n  // create a node to represent where the original\n  // content was first placed, which is useful later on\n  const contentRefElm = elm['s-cr'] = doc.createComment('');\n  contentRefElm['s-cn'] = true;\n  elm.insertBefore(contentRefElm, elm.firstChild);\n};\nconst disconnectedCallback = elm => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    const hostRef = getHostRef(elm);\n    {\n      if (hostRef.$rmListeners$) {\n        hostRef.$rmListeners$.map(rmListener => rmListener());\n        hostRef.$rmListeners$ = undefined;\n      }\n    }\n  }\n};\nconst bootstrapLazy = (lazyBundles, options = {}) => {\n  const endBootstrap = createTime();\n  const cmpTags = [];\n  const exclude = options.exclude || [];\n  const customElements = win.customElements;\n  const head = doc.head;\n  const metaCharset = /*@__PURE__*/head.querySelector('meta[charset]');\n  const visibilityStyle = /*@__PURE__*/doc.createElement('style');\n  const deferredConnectedCallbacks = [];\n  let appLoadFallback;\n  let isBootstrapping = true;\n  Object.assign(plt, options);\n  plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n  lazyBundles.map(lazyBundle => {\n    lazyBundle[1].map(compactMeta => {\n      const cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n        $members$: compactMeta[2],\n        $listeners$: compactMeta[3]\n      };\n      {\n        cmpMeta.$members$ = compactMeta[2];\n      }\n      {\n        cmpMeta.$listeners$ = compactMeta[3];\n      }\n      {\n        cmpMeta.$attrsToReflect$ = [];\n      }\n      {\n        cmpMeta.$watchers$ = {};\n      }\n      const tagName = cmpMeta.$tagName$;\n      const HostElement = class extends HTMLElement {\n        // StencilLazyHost\n        constructor(self) {\n          // @ts-ignore\n          super(self);\n          self = this;\n          registerHost(self, cmpMeta);\n          if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n            // this component is using shadow dom\n            // and this browser supports shadow dom\n            // add the read-only property \"shadowRoot\" to the host element\n            // adding the shadow root build conditionals to minimize runtime\n            {\n              {\n                self.attachShadow({\n                  mode: 'open'\n                });\n              }\n            }\n          }\n        }\n        connectedCallback() {\n          if (appLoadFallback) {\n            clearTimeout(appLoadFallback);\n            appLoadFallback = null;\n          }\n          if (isBootstrapping) {\n            // connectedCallback will be processed once all components have been registered\n            deferredConnectedCallbacks.push(this);\n          } else {\n            plt.jmp(() => connectedCallback(this));\n          }\n        }\n        disconnectedCallback() {\n          plt.jmp(() => disconnectedCallback(this));\n        }\n        componentOnReady() {\n          return getHostRef(this).$onReadyPromise$;\n        }\n      };\n      cmpMeta.$lazyBundleId$ = lazyBundle[0];\n      if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n        cmpTags.push(tagName);\n        customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));\n      }\n    });\n  });\n  {\n    visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n    visibilityStyle.setAttribute('data-styles', '');\n    head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n  }\n  // Process deferred connectedCallbacks now all components have been registered\n  isBootstrapping = false;\n  if (deferredConnectedCallbacks.length) {\n    deferredConnectedCallbacks.map(host => host.connectedCallback());\n  } else {\n    {\n      plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30));\n    }\n  }\n  // Fallback appLoad event\n  endBootstrap();\n};\nconst hostRefs = new WeakMap();\nconst getHostRef = ref => hostRefs.get(ref);\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);\nconst registerHost = (elm, cmpMeta) => {\n  const hostRef = {\n    $flags$: 0,\n    $hostElement$: elm,\n    $cmpMeta$: cmpMeta,\n    $instanceValues$: new Map()\n  };\n  {\n    hostRef.$onReadyPromise$ = new Promise(r => hostRef.$onReadyResolve$ = r);\n    elm['s-p'] = [];\n    elm['s-rc'] = [];\n  }\n  addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);\n  return hostRefs.set(elm, hostRef);\n};\nconst isMemberInElement = (elm, memberName) => memberName in elm;\nconst consoleError = (e, el) => (0, console.error)(e, el);\nconst cmpModules = /*@__PURE__*/new Map();\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n  // loadModuleImport\n  const exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n  const bundleId = cmpMeta.$lazyBundleId$;\n  const module = cmpModules.get(bundleId);\n  if (module) {\n    return module[exportName];\n  }\n  /*!__STENCIL_STATIC_IMPORT_SWITCH__*/\n  return import(/* @vite-ignore */\n  /* webpackInclude: /\\.entry\\.js$/ */\n  /* webpackExclude: /\\.system\\.entry\\.js$/ */\n  /* webpackMode: \"lazy\" */\n  `./${bundleId}.entry.js${''}`).then(importedModule => {\n    {\n      cmpModules.set(bundleId, importedModule);\n    }\n    return importedModule[exportName];\n  }, consoleError);\n};\nconst styles = new Map();\nconst queueDomReads = [];\nconst queueDomWrites = [];\nconst queueTask = (queue, write) => cb => {\n  queue.push(cb);\n  if (!queuePending) {\n    queuePending = true;\n    if (write && plt.$flags$ & 4 /* queueSync */) {\n      nextTick(flush);\n    } else {\n      plt.raf(flush);\n    }\n  }\n};\nconst consume = queue => {\n  for (let i = 0; i < queue.length; i++) {\n    try {\n      queue[i](performance.now());\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n  queue.length = 0;\n};\nconst flush = () => {\n  // always force a bunch of medium callbacks to run, but still have\n  // a throttle on how many can run in a certain time\n  // DOM READS!!!\n  consume(queueDomReads);\n  // DOM WRITES!!!\n  {\n    consume(queueDomWrites);\n    if (queuePending = queueDomReads.length > 0) {\n      // still more to do yet, but we've run out of time\n      // let's let this thing cool off and try again in the next tick\n      plt.raf(flush);\n    }\n  }\n};\nconst nextTick = /*@__PURE__*/cb => promiseResolve().then(cb);\nconst writeTask = /*@__PURE__*/queueTask(queueDomWrites, true);\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\nfunction createCommonjsModule(fn, basedir, module) {\n  return module = {\n    path: basedir,\n    exports: {},\n    require: function (path, base) {\n      return commonjsRequire();\n    }\n  }, fn(module, module.exports), module.exports;\n}\nfunction commonjsRequire() {\n  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\nexport { Host as H, commonjsGlobal as a, bootstrapLazy as b, createCommonjsModule as c, createEvent as d, getElement as g, h, promiseResolve as p, registerInstance as r };"],
  "mappings": "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",
  "names": ["h", "scopeId", "isSvgMode", "newVNode", "self"]
}
