{
  "version": 3,
  "sources": ["../../../../../../node_modules/@sutton-signwriting/sgnw-components/dist/esm/swu-f4cee096.js"],
  "sourcesContent": ["/*!\n * The Sutton SignWriting Web Components\n */\nimport { c as createCommonjsModule, a as commonjsGlobal } from './_commonjsHelpers-383fba37.js';\nvar swu = createCommonjsModule(function (module, exports) {\n  /**\n  * Sutton SignWriting Core Module v1.5.4 (https://github.com/sutton-signwriting/core)\n  * Author: Steve Slevinski  (https://SteveSlevinski.me)\n  * swu.js is released under the MIT License.\n  */\n\n  (function (global, factory) {\n    factory(exports);\n  })(commonjsGlobal, function (exports) {\n    /**\r\n     * Object of regular expressions for SWU strings in UTF-16\r\n     * \r\n     * @alias swu.re\r\n     * @property {string} symbol - regular expressions for a symbol\r\n     * @property {string} coord - regular expressions for a coordinate\r\n     * @property {string} sort - regular expressions for the sorting marker\r\n     * @property {string} box - regular expression for a signbox marker\r\n     * @property {string} prefix - regular expression for a sorting marker followed by one or more symbols\r\n     * @property {string} spatial - regular expression for a symbol followed by a coordinate\r\n     * @property {string} signbox - regular expression for a signbox marker, max coordinate and zero or more spatial symbols\r\n     * @property {string} sign - regular expression for an optional prefix followed by a signbox\r\n     * @property {string} sortable - regular expression for a mandatory prefix followed by a signbox\r\n     */\n    let re$1 = {\n      'symbol': '(?:(?:\\uD8C0[\\uDC01-\\uDFFF])|(?:[\\uD8C1-\\uD8FC][\\uDC00-\\uDFFF])|(?:\\uD8FD[\\uDC00-\\uDC80]))',\n      'coord': '(?:\\uD836[\\uDC0C-\\uDDFF]){2}',\n      'sort': '\\uD836\\uDC00',\n      'box': '\\uD836[\\uDC01-\\uDC04]'\n    };\n    re$1.prefix = `(?:${re$1.sort}(?:${re$1.symbol})+)`;\n    re$1.spatial = `${re$1.symbol}${re$1.coord}`;\n    re$1.signbox = `${re$1.box}${re$1.coord}(?:${re$1.spatial})*`;\n    re$1.sign = `${re$1.prefix}?${re$1.signbox}`;\n    re$1.sortable = `${re$1.prefix}${re$1.signbox}`;\n\n    /**\n     * Object of regular expressions for style strings\n     * \n     * @alias style.re\n     * @type {object}\n     * @property {string} colorize - regular expression for colorize section\n     * @property {string} colorhex - regular expression for color hex values with 3 or 6 characters\n     * @property {string} colorname - regular expression for css color name\n     * @property {string} padding - regular expression for padding section\n     * @property {string} zoom - regular expression for zoom section\n     * @property {string} classbase - regular expression for class name definition\n     * @property {string} id - regular expression for id definition\n     * @property {string} colorbase - regular expression for color hex or color name\n     * @property {string} color - regular expression for single color entry\n     * @property {string} colors - regular expression for double color entry\n     * @property {string} background - regular expression for background section\n     * @property {string} detail - regular expression for color details for line and optional fill\n     * @property {string} detailsym - regular expression for color details for individual symbols\n     * @property {string} classes - regular expression for one or more class names\n     * @property {string} full - full regular expression for style string\n     */\n    let re = {\n      'colorize': 'C',\n      'colorhex': '(?:[0-9a-fA-F]{3}){1,2}',\n      'colorname': '[a-zA-Z]+',\n      'padding': 'P[0-9]{2}',\n      'zoom': 'Z(?:[0-9]+(?:\\\\.[0-9]+)?|x)',\n      'classbase': '-?[_a-zA-Z][_a-zA-Z0-9-]{0,100}',\n      'id': '[a-zA-Z][_a-zA-Z0-9-]{0,100}'\n    };\n    re.colorbase = `(?:${re.colorhex}|${re.colorname})`;\n    re.color = `_${re.colorbase}_`;\n    re.colors = `_${re.colorbase}(?:,${re.colorbase})?_`;\n    re.background = `G${re.color}`;\n    re.detail = `D${re.colors}`;\n    re.detailsym = `D[0-9]{2}${re.colors}`;\n    re.classes = `${re.classbase}(?: ${re.classbase})*`;\n    re.full = `-(${re.colorize})?(${re.padding})?(${re.background})?(${re.detail})?(${re.zoom})?(?:-((?:${re.detailsym})*))?(?:-(${re.classes})?!(?:(${re.id})!)?)?`;\n    const prefixColor = color => {\n      const regex = new RegExp(`^${re.colorhex}$`);\n      return (regex.test(color) ? '#' : '') + color;\n    };\n    const definedProps = obj => Object.fromEntries(Object.entries(obj).filter(([k, v]) => v !== undefined));\n    /**\n     * Function to parse style string to object\n     * @function style.parse\n     * @param {string} styleString - a style string\n     * @returns {StyleObject} elements of style string\n     * @example\n     * style.parse('-CP10G_blue_D_red,Cyan_')\n     * \n     * return {\n     *  'colorize': true,\n     *  'padding': 10,\n     *  'background': 'blue',\n     *  'detail': ['red', 'Cyan']\n     * }\n     */\n\n    const parse$1 = styleString => {\n      const regex = `^${re.full}`;\n      const m = (typeof styleString === 'string' ? styleString.match(new RegExp(regex)) : []) || [];\n      return definedProps({\n        'colorize': !m[1] ? undefined : !!m[1],\n        'padding': !m[2] ? undefined : parseInt(m[2].slice(1)),\n        'background': !m[3] ? undefined : prefixColor(m[3].slice(2, -1)),\n        'detail': !m[4] ? undefined : m[4].slice(2, -1).split(',').map(prefixColor),\n        'zoom': !m[5] ? undefined : m[5] === 'Zx' ? 'x' : parseFloat(m[5].slice(1)),\n        'detailsym': !m[6] ? undefined : m[6].match(new RegExp(re.detailsym, 'g')).map(val => {\n          const parts = val.split('_');\n          const detail = parts[1].split(',').map(prefixColor);\n          return {\n            'index': parseInt(parts[0].slice(1)),\n            'detail': detail\n          };\n        }),\n        'classes': !m[7] ? undefined : m[7],\n        'id': !m[8] ? undefined : m[8]\n      });\n    };\n\n    /** The convert module contains functions to convert between Formal SignWriitng in ASCII (FSW) and SignWriting in Unicode (SWU) characters, along with other types of data.\r\n     * [Characters set definitions](https://tools.ietf.org/id/draft-slevinski-formal-signwriting-09.html#name-characters)\r\n     * @module convert\r\n     */\n    /**\r\n     * Function to convert an SWU number character to an integer\r\n     * @function convert.swu2num\r\n     * @param {string} swuNum - SWU number character\r\n     * @returns {number} Integer value for number\r\n     * @example\r\n     * convert.swu2num('𝤆')\r\n     * \r\n     * return 500\r\n     */\n\n    const swu2num = swuNum => parseInt(swuNum.codePointAt(0)) - 0x1D80C + 250;\n    /**\r\n     * Function to convert a number to an SWU number character\r\n     * @function convert.num2swu\r\n     * @param {number} num - Integer value for number\r\n     * @returns {string} SWU number character\r\n     * @example\r\n     * convert.num2swu(500)\r\n     * \r\n     * return '𝤆'\r\n     */\n\n    const num2swu = num => String.fromCodePoint(0x1D80C + parseInt(num) - 250);\n    /**\r\n     * Function to convert two SWU number characters to an array of x,y integers\r\n     * @function convert.swu2coord\r\n     * @param {string} swuCoord - Two SWU number character\r\n     * @returns {number[]} Array of x,y integers\r\n     * @example\r\n     * convert.swu2coord('𝤆𝤆')\r\n     * \r\n     * return [500, 500]\r\n     */\n\n    const swu2coord = swuCoord => [swu2num(swuCoord.slice(0, 2)), swu2num(swuCoord.slice(2, 4))];\n    /**\r\n     * Function to convert an array of x,y integers to two SWU number characters\r\n     * @function convert.coord2swu\r\n     * @param {number[]} coord - Array of x,y integers\r\n     * @returns {string} Two SWU number character\r\n     * @example\r\n     * convert.coord2swu([500, 500])\r\n     * \r\n     * return '𝤆𝤆'\r\n     */\n\n    const coord2swu = coord => coord.map(num => num2swu(num)).join('');\n    /**\r\n     * Function to convert an SWU symbol character to a code point on plane 4\r\n     * @function convert.swu2code\r\n     * @param {string} swuSym - SWU symbol character\r\n     * @returns {number} Code point on plane 4\r\n     * @example\r\n     * convert.swu2code('񀀁')\r\n     * \r\n     * return 0x40001\r\n     */\n\n    const swu2code = swuSym => parseInt(swuSym.codePointAt(0));\n    const parse = {\n      /**\r\n       * Function to parse an swu symbol with optional coordinate and style string\r\n       * @function swu.parse.symbol\r\n       * @param {string} swuSym - an swu symbol\r\n       * @returns {SymbolObject} elements of swu symbol\r\n       * @example\r\n       * swu.parse.symbol('񀀁𝤆𝤆-C')\r\n       * \r\n       * return {\r\n       *  'symbol': '񀀁',\r\n       *  'coord': [500, 500],\r\n       *  'style': '-C'\r\n       * }\r\n       */\n      symbol: swuSym => {\n        const regex = `^(${re$1.symbol})(${re$1.coord})?(${re.full})?`;\n        const symbol = typeof swuSym === 'string' ? swuSym.match(new RegExp(regex)) : undefined;\n        return {\n          'symbol': symbol ? symbol[1] : undefined,\n          'coord': symbol && symbol[2] ? swu2coord(symbol[2]) : undefined,\n          'style': symbol ? symbol[3] : undefined\n        };\n      },\n      /**\r\n        * Function to parse an swu sign with style string\r\n        * @function swu.parse.sign\r\n        * @param {string} swuSign - an swu sign\r\n        * @returns {SignObject} elements of swu sign\r\n        * @example\r\n        * swu.parse.sign('𝠀񀀒񀀚񋚥񋛩𝠃𝤟𝤩񋛩𝣵𝤐񀀒𝤇𝣤񋚥𝤐𝤆񀀚𝣮𝣭-C')\r\n        * \r\n        * return {\r\n        *  sequence: ['񀀒','񀀚','񋚥','񋛩'],\r\n        *  box: '𝠃',\r\n        *  max: [525, 535],\r\n        *  spatials: [\r\n        *    {\r\n        *      symbol: '񋛩',\r\n        *      coord: [483, 510]\r\n        *    },\r\n        *    {\r\n        *      symbol: '񀀒',\r\n        *      coord: [501, 466]\r\n        *    },\r\n        *    {\r\n        *      symbol: '񋚥',\r\n        *      coord: [510, 500]\r\n        *    },\r\n        *    {\r\n        *      symbol: '񀀚',\r\n        *      coord: [476, 475]\r\n        *    }\r\n        *  ],\r\n        *  style: '-C'\r\n        * }\r\n        */\n      sign: swuSign => {\n        const regex = `^(${re$1.prefix})?(${re$1.signbox})(${re.full})?`;\n        const sign = typeof swuSign === 'string' ? swuSign.match(new RegExp(regex)) : undefined;\n        if (sign) {\n          return {\n            'sequence': sign[1] ? sign[1].slice(2).match(/.{2}/g) : undefined,\n            'box': sign[2].slice(0, 2),\n            'max': swu2coord(sign[2].slice(2, 6)),\n            'spatials': sign[2].length < 7 ? undefined : sign[2].slice(6).match(/(.{6})/g).map(m => {\n              return {\n                symbol: m.slice(0, 2),\n                coord: swu2coord(m.slice(2))\n              };\n            }),\n            'style': sign[3]\n          };\n        } else {\n          return {};\n        }\n      },\n      /**\r\n       * Function to parse an swu text\r\n       * @function swu.parse.text\r\n       * @param {string} swuText - an swu text\r\n       * @returns {string[]} swu signs and punctuations\r\n       * @example\r\n       * swu.parse.text('𝠀񁲡񈩧𝠃𝤘𝤣񁲡𝣳𝣩񈩧𝤉𝣻 𝠀񃊢񃊫񋛕񆇡𝠃𝤘𝤧񃊫𝣻𝤕񃊢𝣴𝣼񆇡𝤎𝤂񋛕𝤆𝣦 񏌁𝣢𝤂')\r\n       * \r\n       * return [\r\n       *  '𝠀񁲡񈩧𝠃𝤘𝤣񁲡𝣳𝣩񈩧𝤉𝣻',\r\n       *  '𝠀񃊢񃊫񋛕񆇡𝠃𝤘𝤧񃊫𝣻𝤕񃊢𝣴𝣼񆇡𝤎𝤂񋛕𝤆𝣦',\r\n       *  '񏌁𝣢𝤂'\r\n       * ]\r\n       */\n      text: swuText => {\n        if (typeof swuText !== 'string') return [];\n        const regex = `(${re$1.sign}(${re.full})?|${re$1.spatial}(${re.full})?)`;\n        const matches = swuText.match(new RegExp(regex, 'g'));\n        return matches ? [...matches] : [];\n      }\n    };\n    /**\r\n     * Function to encode SWU characters using the UTF-16 escape format.\r\n     * @function swu.encode\r\n     * @param {string} swu - SWU characters\r\n     * @returns {string} UTF-16 escape format\r\n     * @example\r\n     * swu.encode('񀀁𝤆𝤆')\r\n     * \r\n     * return '\\\\uD8C0\\\\uDC01\\\\uD836\\\\uDD06\\\\uD836\\\\uDD06'\r\n     */\n\n    const encode = swu => swu.replace(/[\\u007F-\\uFFFF]/g, function (chr) {\n      return \"\\\\u\" + (\"0000\" + chr.charCodeAt(0).toString(16)).substr(-4).toUpperCase();\n    });\n    /**\r\n     * Function to decode UTF-16 escape format to SWU characters.\r\n     * @function swu.decode\r\n     * @param {string} encoded - UTF-16 escape format\r\n     * @returns {string} SWU characters\r\n     * @example\r\n     * swu.decode('\\\\uD8C0\\\\uDC01\\\\uD836\\\\uDD06\\\\uD836\\\\uDD06')\r\n     * \r\n     * return '񀀁𝤆𝤆'\r\n     */\n\n    const decode = encoded => encoded.replace(/\\\\u([0-9A-F]{4})/g, function (match, chr) {\n      return String.fromCharCode(parseInt(chr, 16));\n    });\n    /**\r\n     * Function to decompose an SWU character into UTF-16 surrogate pairs.\r\n     * @function swu.pair\r\n     * @param {string} swuChar - an SWU character\r\n     * @returns {string[]} an array of UTF-16 surrogate pairs\r\n     * @example\r\n     * swu.pair('񀀁')\r\n     * \r\n     * return ['D8C0', 'DC01']\r\n     */\n\n    const pair = swuChar => [swuChar.charCodeAt(0).toString(16).toUpperCase(), swuChar.charCodeAt(1).toString(16).toUpperCase()];\n    const compose = {\n      /**\r\n       * Function to compose an swu symbol with optional coordinate and style string\r\n       * @function swu.compose.symbol\r\n       * @param {SymbolObject} swuSymObject - an swu symbol object\r\n       * @returns {string} an swu symbol string\r\n       * @example\r\n       * swu.compose.symbol({\r\n       *  'symbol': '񀀁',\r\n       *  'coord': [500, 500],\r\n       *  'style': '-C'\r\n       * })\r\n       * \r\n       * return '񀀁𝤆𝤆-C'\r\n       */\n      symbol: swuSymObject => {\n        if (typeof swuSymObject !== 'object' || swuSymObject === null) return undefined;\n        if (typeof swuSymObject.symbol === 'string') {\n          const symbol = (swuSymObject.symbol.match(re$1.symbol) || [''])[0];\n          if (symbol) {\n            const x = swuSymObject.coord && swuSymObject.coord[0] || '';\n            const y = swuSymObject.coord && swuSymObject.coord[1] || '';\n            const coord = x && y ? coord2swu([x, y]) : '';\n            const styleStr = typeof swuSymObject.style === 'string' && (swuSymObject.style.match(re.full) || [''])[0] || '';\n            return symbol + coord + styleStr;\n          }\n        }\n        return undefined;\n      },\n      /**\r\n       * Function to compose an swu sign with style string\r\n       * @function swu.compose.sign\r\n       * @param {SignObject} swuSignObject - an swu sign object\r\n       * @returns {string} an swu sign string\r\n       * @example\r\n       * swu.compose.sign({\r\n       *  sequence: ['񀀒','񀀚','񋚥','񋛩'],\r\n       *  box: '𝠃',\r\n       *  max: [525, 535],\r\n       *  spatials: [\r\n       *    {\r\n       *      symbol: '񋛩',\r\n       *      coord: [483, 510]\r\n       *    },\r\n       *    {\r\n       *      symbol: '񀀒',\r\n       *      coord: [501, 466]\r\n       *    },\r\n       *    {\r\n       *      symbol: '񋚥',\r\n       *      coord: [510, 500]\r\n       *    },\r\n       *    {\r\n       *      symbol: '񀀚',\r\n       *      coord: [476, 475]\r\n       *    }\r\n       *  ],\r\n       *  style: '-C'\r\n       * })\r\n       * \r\n       * return '𝠀񀀒񀀚񋚥񋛩𝠃𝤟𝤩񋛩𝣵𝤐񀀒𝤇𝣤񋚥𝤐𝤆񀀚𝣮𝣭-C'\r\n       */\n      sign: swuSignObject => {\n        if (typeof swuSignObject !== 'object' || swuSignObject === null) return undefined;\n        let box = typeof swuSignObject.box !== 'string' ? '𝠃' : (swuSignObject.box + '𝠃').match(re$1.box);\n        const x = swuSignObject.max && swuSignObject.max[0] || '';\n        const y = swuSignObject.max && swuSignObject.max[1] || '';\n        const max = x && y ? coord2swu([x, y]) : undefined;\n        if (!max) return undefined;\n        let prefix = '';\n        if (swuSignObject.sequence && Array.isArray(swuSignObject.sequence)) {\n          prefix = swuSignObject.sequence.map(key => (key.match(re$1.symbol) || [''])[0]).join('');\n          prefix = prefix ? '𝠀' + prefix : '';\n        }\n        let signbox = '';\n        if (swuSignObject.spatials && Array.isArray(swuSignObject.spatials)) {\n          signbox = swuSignObject.spatials.map(spatial => {\n            if (typeof spatial.symbol === 'string') {\n              const symbol = (spatial.symbol.match(re$1.symbol) || [''])[0];\n              if (symbol) {\n                const x = spatial.coord && spatial.coord[0] || '';\n                const y = spatial.coord && spatial.coord[1] || '';\n                const coord = x && y ? coord2swu([x, y]) : '';\n                if (coord) {\n                  return symbol + coord;\n                }\n              }\n            }\n            return '';\n          }).join('');\n        }\n        const styleStr = typeof swuSignObject.style === 'string' && (swuSignObject.style.match(re.full) || [''])[0] || '';\n        return prefix + box + max + signbox + styleStr;\n      }\n    };\n\n    /**\r\n     * Function to gather sizing information about an swu sign or symbol\r\n     * @function swu.info\r\n     * @param {string} swu - an swu sign or symbol\r\n     * @returns {SegmentInfo} information about the swu string\r\n     * @example\r\n     * swu.info('𝠀񁲡񈩧𝠂𝤘𝤣񁲡𝣳𝣩񈩧𝤉𝣻-P10Z2')\r\n     * \r\n     * return {\r\n     *   minX: 481,\r\n     *   minY: 471,\r\n     *   width: 37,\r\n     *   height: 58,\r\n     *   lane: -1,\r\n     *   padding: 10,\r\n     *   segment: 'sign',\r\n     *   zoom: 2\r\n     * }\r\n     */\n\n    const info = swu => {\n      let lanes = {\n        '𝠁': 0,\n        '𝠂': -1,\n        '𝠃': 0,\n        '𝠄': 1\n      };\n      let parsed = parse.sign(swu);\n      let width, height, segment, x1, x2, y1, y2, lane;\n      if (parsed.spatials) {\n        x1 = Math.min(...parsed.spatials.map(spatial => spatial.coord[0]));\n        x2 = parsed.max[0];\n        width = x2 - x1;\n        y1 = Math.min(...parsed.spatials.map(spatial => spatial.coord[1]));\n        y2 = parsed.max[1];\n        height = y2 - y1;\n        segment = 'sign';\n        lane = parsed.box;\n      } else {\n        parsed = parse.symbol(swu);\n        lane = \"𝠃\";\n        if (parsed.coord) {\n          x1 = parsed.coord[0];\n          width = (500 - x1) * 2;\n          y1 = parsed.coord[1];\n          height = (500 - y1) * 2;\n          segment = 'symbol';\n        } else {\n          x1 = 490;\n          width = 20;\n          y1 = 490;\n          height = 20;\n          segment = 'none';\n        }\n      }\n      let style = parse$1(parsed.style);\n      let zoom = style.zoom || 1;\n      let padding = style.padding || 0;\n      return {\n        minX: x1,\n        minY: y1,\n        width: width,\n        height: height,\n        segment: segment,\n        lane: lanes[lane],\n        padding: padding,\n        zoom: zoom\n      };\n    };\n    const columnDefaults = {\n      'height': 500,\n      'width': 150,\n      'offset': 50,\n      'pad': 20,\n      'margin': 5,\n      'dynamic': false,\n      'background': undefined,\n      'punctuation': {\n        'spacing': true,\n        'pad': 30,\n        'pull': true\n      },\n      'style': {\n        'detail': ['black', 'white'],\n        'zoom': 1\n      }\n    };\n    /**\r\n     * Function to an object of column options with default values\r\n     * \r\n     * @function swu.columnDefaultsMerge\r\n     * @param {ColumnOptions} options - object of column options\r\n     * @returns {ColumnOptions} object of column options merged with column defaults\r\n     * @example\r\n     * swu.columnDefaultsMerge({height: 500,width:150})\r\n     * \r\n     * return {\r\n     *   \"height\": 500,\r\n     *   \"width\": 150,\r\n     *   \"offset\": 50,\r\n     *   \"pad\": 20,\r\n     *   \"margin\": 5,\r\n     *   \"dynamic\": false,\r\n     *   \"punctuation\": {\r\n     *     \"spacing\": true,\r\n     *     \"pad\": 30,\r\n     *     \"pull\": true\r\n     *   },\r\n     *   \"style\": {\r\n     *     \"detail\": [\r\n     *       \"black\",\r\n     *       \"white\"\r\n     *     ],\r\n     *     \"zoom\": 1\r\n     *   }\r\n     * }\r\n     */\n\n    const columnDefaultsMerge = options => {\n      if (typeof options !== 'object') options = {};\n      return {\n        ...columnDefaults,\n        ...options,\n        punctuation: {\n          ...columnDefaults.punctuation,\n          ...options.punctuation\n        },\n        style: {\n          ...columnDefaults.style,\n          ...options.style\n        }\n      };\n    };\n    /**\r\n     * Function to transform an SWU text to an array of columns\r\n     * \r\n     * @function swu.columns\r\n     * @param {string} swuText - SWU text of signs and punctuation\r\n     * @param {ColumnOptions} options - object of column options\r\n     * @returns {{options:ColumnOptions,widths:number[],columns:ColumnData}} object of column options, widths array, and column data\r\n     * @example\r\n     * swu.columns('𝠀񁲡񈩧𝠃𝤘𝤣񁲡𝣳𝣩񈩧𝤉𝣻 𝠀񃊢񃊫񋛕񆇡𝠃𝤘𝤧񃊫𝣻𝤕񃊢𝣴𝣼񆇡𝤎𝤂񋛕𝤆𝣦 񏌁𝣢𝤂', {height: 500,width:150})\r\n     * \r\n     * return {\r\n     *   \"options\": {\r\n     *     \"height\": 500,\r\n     *     \"width\": 150,\r\n     *     \"offset\": 50,\r\n     *     \"pad\": 20,\r\n     *     \"margin\": 5,\r\n     *     \"dynamic\": false,\r\n     *     \"punctuation\": {\r\n     *       \"spacing\": true,\r\n     *       \"pad\": 30,\r\n     *       \"pull\": true\r\n     *     },\r\n     *     \"style\": {\r\n     *       \"detail\": [\r\n     *         \"black\",\r\n     *         \"white\"\r\n     *       ],\r\n     *       \"zoom\": 1\r\n     *     }\r\n     *   },\r\n     *   \"widths\": [\r\n     *     150\r\n     *   ],\r\n     *   \"columns\": [\r\n     *     [\r\n     *       {\r\n     *         \"x\": 56,\r\n     *         \"y\": 20,\r\n     *         \"minX\": 481,\r\n     *         \"minY\": 471,\r\n     *         \"width\": 37,\r\n     *         \"height\": 58,\r\n     *         \"lane\": 0,\r\n     *         \"padding\": 0,\r\n     *         \"segment\": \"sign\",\r\n     *         \"text\": \"𝠀񁲡񈩧𝠃𝤘𝤣񁲡𝣳𝣩񈩧𝤉𝣻\",\r\n     *         \"zoom\": 1\r\n     *       },\r\n     *       {\r\n     *         \"x\": 57,\r\n     *         \"y\": 118,\r\n     *         \"minX\": 482,\r\n     *         \"minY\": 468,\r\n     *         \"width\": 36,\r\n     *         \"height\": 65,\r\n     *         \"lane\": 0,\r\n     *         \"padding\": 0,\r\n     *         \"segment\": \"sign\",\r\n     *         \"text\": \"𝠀񃊢񃊫񋛕񆇡𝠃𝤘𝤧񃊫𝣻𝤕񃊢𝣴𝣼񆇡𝤎𝤂񋛕𝤆𝣦\",\r\n     *         \"zoom\": 1\r\n     *       },\r\n     *       {\r\n     *         \"x\": 39,\r\n     *         \"y\": 203,\r\n     *         \"minX\": 464,\r\n     *         \"minY\": 496,\r\n     *         \"width\": 72,\r\n     *         \"height\": 8,\r\n     *         \"lane\": 0,\r\n     *         \"padding\": 0,\r\n     *         \"segment\": \"symbol\",\r\n     *         \"text\": \"񏌁𝣢𝤂\",\r\n     *         \"zoom\": 1\r\n     *       }\r\n     *     ]\r\n     *   ]\r\n     * }\r\n     */\n\n    const columns = (swuText, options) => {\n      if (typeof swuText !== 'string') return {};\n      const values = columnDefaultsMerge(options);\n      let input = parse.text(swuText);\n      let cursor = 0;\n      let cols = [];\n      let col = [];\n      let plus = 0;\n      let center = parseInt(values.width / 2);\n      let maxHeight = values.height - values.margin;\n      let pullable = true;\n      let finalize = false;\n      for (let val of input) {\n        let informed = info(val);\n        cursor += plus;\n        if (values.punctuation.spacing) {\n          cursor += informed.segment == 'sign' ? values.pad : 0;\n        } else {\n          cursor += values.pad;\n        }\n        finalize = cursor + informed.height > maxHeight;\n        if (finalize && informed.segment == 'symbol' && values.punctuation.pull && pullable) {\n          finalize = false;\n          pullable = false;\n        }\n        if (col.length == 0) {\n          finalize = false;\n        }\n        if (finalize) {\n          cursor = values.pad;\n          cols.push(col);\n          col = [];\n          pullable = true;\n        }\n        col.push(Object.assign(informed, {\n          x: center + values.offset * informed.lane - (500 - informed.minX) * informed.zoom * values.style.zoom,\n          y: cursor,\n          text: val\n        }));\n        cursor += informed.height * informed.zoom * values.style.zoom;\n        if (values.punctuation.spacing) {\n          plus = informed.segment == 'sign' ? values.pad : values.punctuation.pad;\n        } else {\n          plus = values.pad;\n        }\n      }\n      if (col.length) {\n        cols.push(col);\n      } // over height issue when pulling punctuation\n\n      if (values.punctuation.pull) {\n        for (let col of cols) {\n          let last = col[col.length - 1];\n          let diff = last.y + last.height - (values.height - values.margin);\n          if (diff > 0) {\n            let adj = parseInt(diff / col.length) + 1;\n            for (let i in col) {\n              col[i].y -= adj * i + adj;\n            }\n          }\n        }\n      } // contract, expand, adjust\n\n      let widths = [];\n      for (let col of cols) {\n        let min = [center - values.offset - values.pad];\n        let max = [center + values.offset + values.pad];\n        for (let item of col) {\n          min.push(item.x - values.pad);\n          max.push(item.x + item.width + values.pad);\n        }\n        min = Math.min(...min);\n        max = Math.max(...max);\n        let width = values.width;\n        let adj = 0;\n        if (!values.dynamic) {\n          adj = center - parseInt((min + max) / 2);\n        } else {\n          width = max - min;\n          adj = -min;\n        }\n        for (let item of col) {\n          item.x += adj;\n        }\n        widths.push(width);\n      }\n      return {\n        'options': values,\n        'widths': widths,\n        'columns': cols\n      };\n    };\n\n    /**\r\n     * Array of plane 4 code points for kinds of symbols: writing, location, and punctuation.\r\n     * @alias swu.kind\r\n     * @type {array}\r\n     */\n\n    const kind = [0x40001, 0x4efa1, 0x4f2a1];\n    /**\r\n     * Array of plane 4 code points for categories of symbols: hand, movement, dynamics, head, trunk & limb, location, and punctuation.\r\n     * @alias swu.category\r\n     * @type {array}\r\n     */\n\n    const category = [0x40001, 0x461e1, 0x4bca1, 0x4bfa1, 0x4e8e1, 0x4efa1, 0x4f2a1];\n    /**\r\n     * Array of plane 4 code points for the 30 symbol groups.\r\n     * @alias swu.group\r\n     * @type {array}\r\n     */\n\n    const group = [0x40001, 0x40541, 0x40b41, 0x41981, 0x41c81, 0x43241, 0x43d81, 0x445c1, 0x44ce1, 0x45be1, 0x461e1, 0x46841, 0x46fc1, 0x47fe1, 0x485e1, 0x49301, 0x49e41, 0x4a4a1, 0x4afe1, 0x4b521, 0x4bca1, 0x4bfa1, 0x4c3c1, 0x4cfc1, 0x4d621, 0x4e161, 0x4e8e1, 0x4ec41, 0x4efa1, 0x4f2a1];\n    /**\r\n     * Object of symbol ranges with starting and ending code points on plane 4.\r\n     * \r\n     *   { all, writing, hand, movement, dynamic, head, hcenter, vcenter, trunk, limb, location, punctuation }\r\n     * @alias swu.ranges\r\n     * @type {object}\r\n     */\n\n    const ranges = {\n      'all': [0x40001, 0x4f480],\n      'writing': [0x40001, 0x4efa0],\n      'hand': [0x40001, 0x461e0],\n      'movement': [0x461e1, 0x4bca0],\n      'dynamic': [0x4bca1, 0x4bfa0],\n      'head': [0x4bfa1, 0x4e8e0],\n      'hcenter': [0x4bfa1, 0x4e8e0],\n      'vcenter': [0x4bfa1, 0x4ec40],\n      'trunk': [0x4e8e1, 0x4ec40],\n      'limb': [0x4ec41, 0x4efa0],\n      'location': [0x4efa1, 0x4f2a0],\n      'punctuation': [0x4f2a1, 0x4f480]\n    };\n    /**\r\n     * Function to test if symbol is of a certain type.\r\n     * @function swu.isType\r\n     * @param {string} swuSym - an SWU symbol character\r\n     * @param {string} type - the name of a symbol range\r\n     * @returns {boolean} is symbol of specified type\r\n     * @example\r\n     * swu.isType('񀀁', 'hand')\r\n     * \r\n     * return true\r\n     */\n\n    const isType = (swuSym, type) => {\n      const parsed = parse.symbol(swuSym);\n      if (parsed.symbol) {\n        const code = swu2code(parsed.symbol);\n        const range = ranges[type];\n        if (range) {\n          return range[0] <= code && range[1] >= code;\n        }\n      }\n      return false;\n    };\n\n    /**\r\n     * Array of colors associated with the seven symbol categories.\r\n     * @alias swu.colors\r\n     * @type {array}\r\n     */\n\n    const colors = ['#0000CC', '#CC0000', '#FF0099', '#006600', '#000000', '#884411', '#FF9900'];\n    /**\r\n     * Function that returns the standardized color for a symbol.\r\n     * @function swu.colorize\r\n     * @param {string} swuSym - an SWU symbol character\r\n     * @returns {string} name of standardized color for symbol\r\n     * @example\r\n     * swu.colorize('񀀁')\r\n     * \r\n     * return '#0000CC'\r\n     */\n\n    const colorize = swuSym => {\n      const parsed = parse.symbol(swuSym);\n      let color = '#000000';\n      if (parsed.symbol) {\n        const code = swu2code(parsed.symbol);\n        const index = category.findIndex(val => val > code);\n        color = colors[index < 0 ? 6 : index - 1];\n      }\n      return color;\n    };\n    exports.category = category;\n    exports.colorize = colorize;\n    exports.colors = colors;\n    exports.columnDefaults = columnDefaults;\n    exports.columnDefaultsMerge = columnDefaultsMerge;\n    exports.columns = columns;\n    exports.compose = compose;\n    exports.decode = decode;\n    exports.encode = encode;\n    exports.group = group;\n    exports.info = info;\n    exports.isType = isType;\n    exports.kind = kind;\n    exports.pair = pair;\n    exports.parse = parse;\n    exports.ranges = ranges;\n    exports.re = re$1;\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n  });\n\n  /* support ongoing development on https://patreon.com/signwriting */\n});\nexport { swu as s };"],
  "mappings": "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",
  "names": ["exports", "swu", "x", "y", "col"]
}
